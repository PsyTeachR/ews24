---
title: "EWS"
author: "Sean Westwood"
format: revealjs
---

```{r, include = FALSE}
knitr::opts_chunk$set(error = TRUE,
                      echo = TRUE,
                      message = FALSE,
                      eval = FALSE)
# remember to set eval = FALSE on code chunks that I don't want code to run
# this may make more sense than error depending if we want error message
```

# Demystifying functions
::: {.incremental}


:::

## Example: SEM {auto-animate=true}

-   what mysteries stand in the way?
    -   scary equations
    -   functions as black boxes


## The Function Function {auto-animate=true}
::: {style="font-size: .8em"}
- **Input**: We use the function function to specify our inputs

```{r}
function(`input`)
```
:::

## The Function Function {auto-animate=true}
::: {style="font-size: .8em"}
- **Input**: We use the function function to specify our inputs

```{r}
function(`input`)
```


- **Process**: We specify what the function does with the input inside the curly brackets

```{r}
function(`input`){
  # inside the curly brackets goes the process
}
```
:::

## The Function Function {auto-animate=true}
::: {style="font-size: .8em"}
- **Input**: We use the function function to specify our inputs

```{r}
function(`input`)
```


- **Process**: We specify what the function does with the input inside the curly brackets

```{r}
function(`input`){
  # inside the curly brackets goes the process
}
```

- **Output**: We specify what the function gives us back using the `return()` function

```{r}
function(`input`){
  `process` # inside the curly brackets goes the process
  return(`output`) # the outcome of your process can go in here 
}
```
:::

## Step 1: I Make a Mean Function

::: {style="font-size: .8em"}
The first key component of a standard error function is the mean. This is essential for calculating the variance, which is required for the SEM. The mean is a reflection of the 'centre' of a set of numbers, whilst being sensitive to extreme values within the set (unlike the median).
:::

<!-- Insert Mean Figure -->

::: {style="font-size: .8em"}
The mean is calculated by adding together all the values in the set, and dividing the total by the number of values:
:::

<!-- Insert Latex equation -->

## Mean Function: Input

::: {style="font-size: .8em"}
A vector of numeric values (`x`)
:::

::: {.absolute top=400 left=0 width="1000" height="300"}
```{r}
mean_function <- function(x){
  
  
  
  
  
  
}
```
:::
## Mean Function: Process {auto-animate=true}

::: {style="font-size: .8em"}
1. Add up all the values within `x`
:::
::: {.absolute top=400 left=0 width="1000" height="300"}
```{r}
mean_function <- function(x){
  
  numerator     <- sum(x)
  
  
  
  
}
```
:::
## Mean Function: Process {auto-animate=true}

::: {style="font-size: .8em"}
1. Add up all the values within `x`
2. Find the number of values within `x`
:::
::: {.absolute top=400 left=0 width="1000" height="300"}
```{r}
mean_function <- function(x){
  
  numerator     <- sum(x)
  denominator   <- length(x)
  
  
  
}
```
:::
## Mean Function: Process {auto-animate=true}

::: {style="font-size: .8em"}
1. Add up all the values within `x`
2. Find the number of values within `x`
3. Divide the sum of values by the number of values
:::
::: {.absolute top=400 left=0 width="1000" height="300"}
```{r}
mean_function <- function(x){
  
  numerator     <- sum(x)
  denominator   <- length(x)
  output        <- numerator/denominator
  
  
}
```
:::
## Step 1: I Make a Mean Function {auto-animate=true}

::: {style="font-size: .8em"}
Return the value contained in `output`
:::
::: {.absolute top=400 left=0 width="1000" height="300"}
```{r, eval=TRUE}
mean_function <- function(x){
  
  numerator     <- sum(x)
  denominator   <- length(x)
  output        <- numerator/denominator
  
  return(output)
}
```
:::
## Step 1: Mean Testing

::: {style="font-size: .8em"}
Now that we have made our function, we can test it by comparing the output it gives us to the regular old `mean()` function in base R!

Let's simulate some random values to test our function with:
:::

```{r, eval=TRUE}
test_data <- rnorm(n = 10, mean = 0, sd = 1)
test_data
```

## Step 1: Mean Testing

::: {style="font-size: .8em"}
Now that we have made our function, we can test it by comparing the output it gives us to the regular old `mean()` function in base R!

Now let's use `test_data` as the input to our function and compare the output with `mean`:
:::

```{r, eval=TRUE}
# print the mean that our function calculates
mean_function(test_data)
# print the mean that the base R function calculates
mean(test_data)
# return TRUE if the two calculated means are equivalent
mean_function(test_data) == mean(test_data)
```

## Step 2: Variance is the Spice of Life

::: {style="font-size: .8em"}
One of the two key components of the SEM is the variance of a sample. This reflects the spread of data in our sample, which can be visualised as the width of a distribution:
:::

```{r}
# plot the 3 variance curves from my other script
```

::: {style="font-size: .8em"}
Our mean function will come in very useful when we need to calculate the variance. This is because the variance formula requires us to subtract the mean from each value in our set, square the result, add them all together, and finally divide by the number of values minus 1:
:::

<!-- insert latex equation -->

## Step 2: Variance is the Spice of Life

::: {style="font-size: .8em"}
Input: A vector of numeric values (`x`)
:::

```{r}
var_function <- function(x){
  
  
  
  
  
  
  
}
```

## Step 2: Variance is the Spice of Life

::: {style="font-size: .8em"}
Input: A vector of numeric values (`x`)

Process:

-   Step 1: calculate the mean of `x` using our `mean_function()`
:::

```{r}
var_function <- function(x){
  
  var_mean <- mean_function(x)
  
  
  
  
  
  
}
```

## Step 2: Variance is the Spice of Life

::: {style="font-size: .8em"}
Input: A vector of numeric values (`x`)

Process:

-   Step 1: calculate the mean of `x`

-   Step 2: calculate the top part (numerator) of the formula

    1.  subtract the mean from each value of x
:::

```{r}
var_function <- function(x){
  
  var_mean <- mean_function(x)
  numerator <- sapply(x,`-`,var_mean)
  
  
  
  
}
```

## Step 2: Variance is the Spice of Life

::: {style="font-size: .8em"}
Input: A vector of numeric values (`x`)

Process:

-   Step 1: calculate the mean of `x`

-   Step 2: calculate the top part (numerator) of the formula

    1.  subtract the mean from each value of x
    2.  square each of the resulting values
:::

```{r}
var_function <- function(x){
  
  var_mean <- mean_function(x)
  numerator <- sapply(x,`-`,var_mean)^2
  
  
  
  
}
```

## Step 2: Variance is the Spice of Life

::: {style="font-size: .8em"}
Input: A vector of numeric values (`x`)

Process:

-   Step 1: calculate the mean of `x`

-   Step 2: calculate the top part (numerator) of the formula

    1.  subtract the mean from each value of x
    2.  square each of the resulting values
    3.  sum all of the squared values together
:::

```{r}
var_function <- function(x){
  
  var_mean <- mean_function(x)
  numerator <- sapply(x,`-`,var_mean)^2 |> sum()
  
  
  
  
}
```

## Step 2: Variance is the Spice of Life

::: {style="font-size: .8em"}
Input: A vector of numeric values (`x`)

Process:

-   Step 1: calculate the mean of `x`

-   Step 2: calculate the top part (numerator) of the formula

    1.  subtract the mean from each value of x
    2.  square each of the resulting values
    3.  sum all of the squared values together

-   Step 3: calculate the bottom part (denominator) of the formula
:::

```{r}
var_function <- function(x){
  
  var_mean <- mean_function(x)
  numerator <- sapply(x,`-`,var_mean)^2 |> sum()
  denominator <- length(x) - 1
  
  
  
}
```

## Step 2: Variance is the Spice of Life

::: {style="font-size: .8em"}
Input: A vector of numeric values (`x`)

Process:

-   Step 1: calculate the mean of `x`

-   Step 2: calculate the top part (numerator) of the formula

    1.  subtract the mean from each value of x
    2.  square each of the resulting values
    3.  sum all of the squared values together

-   Step 3: calculate the bottom part (denominator) of the formula

-   Step 4: divide the numerator by the denominator
:::

```{r}
var_function <- function(x){
  
  var_mean <- mean_function(x)
  numerator <- sapply(x,`-`,var_mean)^2 |> sum()
  denominator <- length(x) - 1
  var_output <- numerator/denominator

  
}
```

## Step 2: Variance is the Spice of Life

::: {style="font-size: .8em"}
Input: A vector of numeric values (`x`)

Process:

-   Step 1: calculate the mean of `x`

-   Step 2: calculate the top part (numerator) of the formula

    1.  subtract the mean from each value of x
    2.  square each of the resulting values
    3.  sum all of the squared values together

-   Step 3: calculate the bottom part (denominator) of the formula

-   Step 4: divide the numerator by the denominator

Output: return the output of step 4 in the process
:::

```{r, eval=TRUE}
var_function <- function(x){
  
  var_mean <- mean_function(x)
  numerator <- sapply(x,`-`,var_mean)^2 |> sum()
  denominator <- length(x) - 1
  var_output <- numerator/denominator
  
  return(var_output)
}
```

## Step 2: Variance Testing

::: {style="font-size: .8em"}
Remember our `test_data` from earlier?
:::

```{r, eval=TRUE}
test_data
```

::: {style="font-size: .8em"}
Let's see if we can successfully apply our variance function to this data:
:::

```{r, eval=TRUE}
# print the mean that our function calculates
var_function(test_data)
# print the mean that the base R function calculates
var(test_data)
# return TRUE if the two calculated means are equivalent
var_function(test_data) == var(test_data)
```

## Step 3: Making a Standard Error (but in a good way)

::: {style="font-size: .8em"}
The Standard Error of the Mean is a statistical concept that reflects the **standard deviation of sample means we would get from sampling the same population over and over, for a given sample size.** It gives us an idea of how close an estimate our sample mean is of the true population mean, and is the basis for other useful stats like confidence intervals.

The calculation for this is actually very simple:
:::

<!-- insert latex equation -->

::: {style="font-size: .8em"}
Where the numerator is the standard deviation of the sample, i.e. the square root of the variance.
:::

## Step 3: Making a Standard Error (but in a good way)

::: {style="font-size: .8em"}
Input: A vector of numeric values (`x`)

Process:

-   Step 1: calculate the mean of `x`

-   Step 2: calculate the top part (numerator) of the formula

    1.  subtract the mean from each value of x
    2.  square each of the resulting values
    3.  sum all of the squared values together

-   Step 3: calculate the bottom part (denominator) of the formula

-   Step 4: divide the numerator by the denominator Output: return the output of step 4 in the process
:::

```{r, eval=TRUE}
sem_function <- function(x){
  
  sem_var <- var_function(x)
  numerator <- sqrt(sem_var)
  denominator <- sqrt(length(x))
  sem_output <- numerator/denominator
  
  return(sem_output)
}
```

```{r}
sem_function_short <- function(x){
  var_function(x)^.5 / length(x)^.5
}
```

## Taking it further

-   more complex concepts + functions
-   mapping, looping, possibility to make things more complex (but not in this talk)

Notes - one thing that will come up a lot is people won't always use as intended - ie ERRORS - Tobi will now show how we can anticipate common errors and help our users understand where and why things are breaking

---
title: "EWS"
author: "Sean + Lisa"
format: revealjs
---

```{r, include = FALSE}
knitr::opts_chunk$set(error = TRUE,
                      echo = TRUE,
                      message = FALSE,
                      eval = FALSE)
# remember to set evel = FALSE on code chunks that I don't want code to run
# this may make more sense than error depending if we want error message
```

# Intro Slide

# Demystifying functions

## Intro to the concept

## Example: SEM

-   what mysteries stand in the way?
    -   scary equations
    -   lack of understanding of how functions work
    -   knowing when to apply it?
    -   knowing what inputs you need
    -   break it down...

## Step 1: how to build a function

```{r}
# structure of functions
```

## Input

We use the function function to specify our inputs

```{r}
function(`input`)
```

## Process

```{r}
function(`input`){
  # inside the curly brackets goes the process
}
```

## Output

```{r}
function(`input`){
  `process` # inside the curly brackets goes the process
  return(`output`) # the outcome of your process can go in here 
}
```

## Step 1: I Make a Mean Function

::: {style="font-size: .8em"}
The first key component of a standard error function is the mean. This is essential for calculating the variance, which is required for the SEM. The mean is a reflection of the 'centre' of a set of numbers, whilst being sensitive to extreme values within the set (unlike the median).
:::

<!-- Insert Mean Figure -->

::: {style="font-size: .8em"}
The mean is calculated by adding together all the values in the set, and dividing the total by the number of values:
:::

<!-- Insert Latex equation -->

## Step 1: I Make a Mean Function

::: {style="font-size: .8em"}
Input: a vector of numeric values (`x`)
:::

```{r}
mean_function <- function(x){
  
  
  
  
  
  
}
```

## Step 1: I Make a Mean Function

::: {style="font-size: .8em"}
Input: a vector of numeric values (`x`)

Process:

-   Step 1: Add up all the values within `x`
:::

```{r}
mean_function <- function(x){
  
  mean_sum <- sum(x)
  
  
  
  
}
```

## Step 1: I Make a Mean Function

::: {style="font-size: .8em"}
Input: a vector of numeric values (`x`)

Process:

-   Step 1: Add up all the values within `x`
-   Step 2: Find the number of values within `x`
:::

```{r}
mean_function <- function(x){
  
  mean_sum <- sum(x)
  mean_n   <- length(x)
  
  
  
}
```

## Step 1: I Make a Mean Function

::: {style="font-size: .8em"}
Input: a vector of numeric values (`x`)

Process:

-   Step 1: Add up all the values within `x`
-   Step 2: Find the number of values within `x`
-   Step 3: Divide the sum of values by the number of values
:::

```{r}
mean_function <- function(x){
  
  mean_sum    <- sum(x)
  mean_n      <- length(x)
  mean_output <- mean-sum/mean_n
  
  
}
```

## Step 1: I Make a Mean Function

::: {style="font-size: .8em"}
Input: a vector of numeric values (`x`)

Process:

-   Step 1: Add up all the values within `x`
-   Step 2: Find the number of values within `x`
-   Step 3: Divide the sum of values by the number of values

Output: return the result of the division in step 3
:::

```{r, eval=TRUE}
mean_function <- function(x){
  
  mean_sum    <- sum(x)
  mean_n      <- length(x)
  mean_output <- mean_sum/mean_n
  
  return(mean_output)
}
```

## Step 1: Mean Testing

::: {style="font-size: .8em"}
Now that we have made our function, we can test it by comparing the output it gives us to the regular old `mean()` function in base R!

Let's simulate some random values to test our function with:
:::

```{r, eval=TRUE}
test_data = rnorm(n = 10, mean = 0, sd = 1)
test_data
```

## Step 1: Mean Testing

::: {style="font-size: .8em"}
Now that we have made our function, we can test it by comparing the output it gives us to the regular old `mean()` function in base R!

Now let's use `test_data` as the input to our function and compare the output with `mean`:
:::

```{r, eval=TRUE}
# print the mean that our function calculates
mean_function(test_data)
# print the mean that the base R function calculates
mean(test_data)
# return TRUE if the two calculated means are equivalent
mean_function(test_data) == mean(test_data)
```

## Step 2: Variance is the Spice of Life

::: {style="font-size: .8em"}
One of the two key components of the SEM is the variance of a sample. This reflects the spread of data in our sample, which can be visualised as the width of a distribution:
:::

```{r}
# plot the 3 variance curves from my other script
```

::: {style="font-size: .8em"}
Our mean function will come in very useful when we need to calculate the variance. This is because the variance formula requires us to subtract the mean from each value in our set, square the result, add them all together, and finally divide by the number of values minus 1:
:::

<!-- insert latex equation -->

## Step 2: Variance is the Spice of Life

::: {style="font-size: .8em"}
Input: A vector of numeric values (`x`)
:::

```{r}
var_function <- function(x){
  
  
  
  
  
  
  
}
```

## Step 2: Variance is the Spice of Life

::: {style="font-size: .8em"}
Input: A vector of numeric values (`x`)

Process:

-   Step 1: calculate the mean of `x` using our `mean_function()`
:::

```{r}
var_function <- function(x){
  
  var_mean <- mean_function(x)
  
  
  
  
  
  
}
```

## Step 2: Variance is the Spice of Life

::: {style="font-size: .8em"}
Input: A vector of numeric values (`x`)

Process:

-   Step 1: calculate the mean of `x`

-   Step 2: calculate the top part (numerator) of the formula

    1.  subtract the mean from each value of x
:::

```{r}
var_function <- function(x){
  
  var_mean <- mean_function(x)
  numerator <- sapply(x,`-`,var_mean)
  
  
  
  
}
```

## Step 2: Variance is the Spice of Life

::: {style="font-size: .8em"}
Input: A vector of numeric values (`x`)

Process:

-   Step 1: calculate the mean of `x`

-   Step 2: calculate the top part (numerator) of the formula

    1.  subtract the mean from each value of x
    2.  square each of the resulting values
:::

```{r}
var_function <- function(x){
  
  var_mean <- mean_function(x)
  numerator <- sapply(x,`-`,var_mean)^2
  
  
  
  
}
```

## Step 2: Variance is the Spice of Life

::: {style="font-size: .8em"}
Input: A vector of numeric values (`x`)

Process:

-   Step 1: calculate the mean of `x`

-   Step 2: calculate the top part (numerator) of the formula

    1.  subtract the mean from each value of x
    2.  square each of the resulting values
    3.  sum all of the squared values together
:::

```{r}
var_function <- function(x){
  
  var_mean <- mean_function(x)
  numerator <- sapply(x,`-`,var_mean)^2 |> sum()
  
  
  
  
}
```

## Step 2: Variance is the Spice of Life

::: {style="font-size: .8em"}
Input: A vector of numeric values (`x`)

Process:

-   Step 1: calculate the mean of `x`

-   Step 2: calculate the top part (numerator) of the formula

    1.  subtract the mean from each value of x
    2.  square each of the resulting values
    3.  sum all of the squared values together

-   Step 3: calculate the bottom part (denominator) of the formula
:::

```{r}
var_function <- function(x){
  
  var_mean <- mean_function(x)
  numerator <- sapply(x,`-`,var_mean)^2 |> sum()
  denominator <- length(x) - 1
  
  
  
}
```

## Step 2: Variance is the Spice of Life

::: {style="font-size: .8em"}
Input: A vector of numeric values (`x`)

Process:

-   Step 1: calculate the mean of `x`

-   Step 2: calculate the top part (numerator) of the formula

    1.  subtract the mean from each value of x
    2.  square each of the resulting values
    3.  sum all of the squared values together

-   Step 3: calculate the bottom part (denominator) of the formula

-   Step 4: divide the numerator by the denominator
:::

```{r}
var_function <- function(x){
  
  var_mean <- mean_function(x)
  numerator <- sapply(x,`-`,var_mean)^2 |> sum()
  denominator <- length(x) - 1
  var_output <- numerator/denominator

  
}
```

## Step 2: Variance is the Spice of Life

::: {style="font-size: .8em"}
Input: A vector of numeric values (`x`)

Process:

-   Step 1: calculate the mean of `x`

-   Step 2: calculate the top part (numerator) of the formula

    1.  subtract the mean from each value of x
    2.  square each of the resulting values
    3.  sum all of the squared values together

-   Step 3: calculate the bottom part (denominator) of the formula

-   Step 4: divide the numerator by the denominator

Output: return the output of step 4 in the process
:::

```{r, eval=TRUE}
var_function <- function(x){
  
  var_mean <- mean_function(x)
  numerator <- sapply(x,`-`,var_mean)^2 |> sum()
  denominator <- length(x) - 1
  var_output <- numerator/denominator
  
  return(var_output)
}
```

## Step 2: Variance Testing

::: {style="font-size: .8em"}
Remember our `test_data` from earlier?
:::

```{r, eval=TRUE}
test_data
```

::: {style="font-size: .8em"}
Let's see if we can successfully apply our variance function to this data:
:::

```{r, eval=TRUE}
# print the mean that our function calculates
var_function(test_data)
# print the mean that the base R function calculates
var(test_data)
# return TRUE if the two calculated means are equivalent
var_function(test_data) == var(test_data)
```

## Step 3: Making a Standard Error (but in a good way)

::: {style="font-size: .8em"}
The Standard Error of the Mean is a statistical concept that reflects the **standard deviation of sample means we would get from sampling the same population over and over, for a given sample size.** It gives us an idea of how close an estimate our sample mean is of the true population mean, and is the basis for other useful stats like confidence intervals.

The calculation for this is actually very simple:
:::

<!-- insert latex equation -->

::: {style="font-size: .8em"}
Where the numerator is the standard deviation of the sample, i.e. the square root of the variance.
:::

## Step 3: Making a Standard Error (but in a good way)

::: {style="font-size: .8em"}
Input: A vector of numeric values (`x`)

Process:

-   Step 1: calculate the mean of `x`

-   Step 2: calculate the top part (numerator) of the formula

    1.  subtract the mean from each value of x
    2.  square each of the resulting values
    3.  sum all of the squared values together

-   Step 3: calculate the bottom part (denominator) of the formula

-   Step 4: divide the numerator by the denominator Output: return the output of step 4 in the process
:::

```{r, eval=TRUE}
sem_function <- function(x){
  
  sem_var <- var_function(x)
  numerator <- sqrt(sem_var)
  denominator <- sqrt(length(x))
  sem_output <- numerator/denominator
  
  return(sem_output)
}
```

```{r}
sem_function_short <- function(x){
  var_function(x)^.5 / length(x)^.5
}
```

## Taking it further

-   more complex concepts + functions
-   mapping, looping, possibility to make things more complex (but not in this talk)

Notes - one thing that will come up a lot is people won't always use as intended - ie ERRORS - Tobi will now show how we can anticipate common errors and help our users understand where and why things are breaking
